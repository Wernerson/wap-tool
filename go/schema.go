// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

// Wochenarbeitsplan (WAP): schedule for a military week with events and logistical
// informations.
type WapJson struct {
	// Defines categories for events to display them styled.
	Categories []WapJsonCategoriesElem `json:"categories,omitempty" yaml:"categories,omitempty" mapstructure:"categories,omitempty"`

	// Days corresponds to the JSON schema field "days".
	Days []WapJsonDaysElem `json:"days,omitempty" yaml:"days,omitempty" mapstructure:"days,omitempty"`

	// Metadata concerning the WAP.
	Meta *WapJsonMeta `json:"meta,omitempty" yaml:"meta,omitempty" mapstructure:"meta,omitempty"`

	// Additional remarks.
	Remarks []string `json:"remarks,omitempty" yaml:"remarks,omitempty" mapstructure:"remarks,omitempty"`
}

type WapJsonCategoriesElem struct {
	// Color to give the category
	Color *string `json:"color,omitempty" yaml:"color,omitempty" mapstructure:"color,omitempty"`

	// Short identifier for the category. To be used as reference from events.
	Identifier string `json:"identifier" yaml:"identifier" mapstructure:"identifier"`

	// Name of the category
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WapJsonCategoriesElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["identifier"]; raw != nil && !ok {
		return fmt.Errorf("field identifier in WapJsonCategoriesElem: required")
	}
	type Plain WapJsonCategoriesElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = WapJsonCategoriesElem(plain)
	return nil
}

// Each day in the WAP.
type WapJsonDaysElem struct {
	// The columns this day is subdivided in. Can be refered by appearsIn for events.
	Columns []string `json:"columns,omitempty" yaml:"columns,omitempty" mapstructure:"columns,omitempty"`

	// All events that occur on this day.
	Events []WapJsonDaysElemEventsElem `json:"events,omitempty" yaml:"events,omitempty" mapstructure:"events,omitempty"`

	// Offset from firstDay.
	Offset *float64 `json:"offset,omitempty" yaml:"offset,omitempty" mapstructure:"offset,omitempty"`
}

// An event.
type WapJsonDaysElemEventsElem struct {
	// Columns in which this event should appear.
	AppearsIn []string `json:"appearsIn,omitempty" yaml:"appearsIn,omitempty" mapstructure:"appearsIn,omitempty"`

	// Identifer of a defined category.
	Category *string `json:"category,omitempty" yaml:"category,omitempty" mapstructure:"category,omitempty"`

	// End time. In format HH:MM
	End string `json:"end" yaml:"end" mapstructure:"end"`

	// Description of the event to be displayed as a footnote below the plan.
	Footnote interface{} `json:"footnote,omitempty" yaml:"footnote,omitempty" mapstructure:"footnote,omitempty"`

	// Location where the event takes place.
	Location *string `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// if the event repeats periodically.
	Repeats *WapJsonDaysElemEventsElemRepeats `json:"repeats,omitempty" yaml:"repeats,omitempty" mapstructure:"repeats,omitempty"`

	// The person responsible for this event.
	Responsible *string `json:"responsible,omitempty" yaml:"responsible,omitempty" mapstructure:"responsible,omitempty"`

	// Start time. In format HH:MM
	Start string `json:"start" yaml:"start" mapstructure:"start"`

	// Title of the event.
	Title string `json:"title" yaml:"title" mapstructure:"title"`
}

type WapJsonDaysElemEventsElemRepeats string

const WapJsonDaysElemEventsElemRepeatsDaily WapJsonDaysElemEventsElemRepeats = "daily"
const WapJsonDaysElemEventsElemRepeatsNo WapJsonDaysElemEventsElemRepeats = "no"
const WapJsonDaysElemEventsElemRepeatsWeekly WapJsonDaysElemEventsElemRepeats = "weekly"

var enumValues_WapJsonDaysElemEventsElemRepeats = []interface{}{
	"no",
	"daily",
	"weekly",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WapJsonDaysElemEventsElemRepeats) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WapJsonDaysElemEventsElemRepeats {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WapJsonDaysElemEventsElemRepeats, v)
	}
	*j = WapJsonDaysElemEventsElemRepeats(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WapJsonDaysElemEventsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["end"]; raw != nil && !ok {
		return fmt.Errorf("field end in WapJsonDaysElemEventsElem: required")
	}
	if _, ok := raw["start"]; raw != nil && !ok {
		return fmt.Errorf("field start in WapJsonDaysElemEventsElem: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in WapJsonDaysElemEventsElem: required")
	}
	type Plain WapJsonDaysElemEventsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[0-2]\d:[0-5]\d$`, string(plain.End)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "End", `^[0-2]\d:[0-5]\d$`)
	}
	if matched, _ := regexp.MatchString(`^[0-2]\d:[0-5]\d$`, string(plain.Start)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Start", `^[0-2]\d:[0-5]\d$`)
	}
	*j = WapJsonDaysElemEventsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WapJsonDaysElem) UnmarshalJSON(value []byte) error {
	type Plain WapJsonDaysElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Offset != nil && 0 > *plain.Offset {
		return fmt.Errorf("field %s: must be >= %v", "offset", 0)
	}
	*j = WapJsonDaysElem(plain)
	return nil
}

// Metadata concerning the WAP.
type WapJsonMeta struct {
	// The person who created the WAP.
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// The latest time displayed in the WAP. Given in format HH-MM
	EndTime *string `json:"endTime,omitempty" yaml:"endTime,omitempty" mapstructure:"endTime,omitempty"`

	// The first day of the WAP. Given in format YYYY-MM-DD
	FirstDay string `json:"firstDay" yaml:"firstDay" mapstructure:"firstDay"`

	// The last day of the WAP. Given in format YYYY-MM-DD
	LastDay *string `json:"lastDay,omitempty" yaml:"lastDay,omitempty" mapstructure:"lastDay,omitempty"`

	// The earliest time displayed in the WAP. Given in format HH-MM
	StartTime *string `json:"startTime,omitempty" yaml:"startTime,omitempty" mapstructure:"startTime,omitempty"`

	// The title of the WAP. Often contains the week number.
	Title string `json:"title" yaml:"title" mapstructure:"title"`

	// The unit the WAP is for
	Unit *string `json:"unit,omitempty" yaml:"unit,omitempty" mapstructure:"unit,omitempty"`

	// The version of the WAP or when it was last modified.
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WapJsonMeta) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in WapJsonMeta: required")
	}
	if _, ok := raw["firstDay"]; raw != nil && !ok {
		return fmt.Errorf("field firstDay in WapJsonMeta: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in WapJsonMeta: required")
	}
	type Plain WapJsonMeta
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.EndTime != nil {
		if matched, _ := regexp.MatchString(`^[0-2]\d:[0-5]\d$`, string(*plain.EndTime)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "EndTime", `^[0-2]\d:[0-5]\d$`)
		}
	}
	if matched, _ := regexp.MatchString(`^\d{4}-([0][1-9]|1[0-2])-([0][1-9]|[1-2]\d|3[01])$`, string(plain.FirstDay)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "FirstDay", `^\d{4}-([0][1-9]|1[0-2])-([0][1-9]|[1-2]\d|3[01])$`)
	}
	if plain.LastDay != nil {
		if matched, _ := regexp.MatchString(`^\d{4}-([0][1-9]|1[0-2])-([0][1-9]|[1-2]\d|3[01])$`, string(*plain.LastDay)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "LastDay", `^\d{4}-([0][1-9]|1[0-2])-([0][1-9]|[1-2]\d|3[01])$`)
		}
	}
	if plain.StartTime != nil {
		if matched, _ := regexp.MatchString(`^[0-2]\d:[0-5]\d$`, string(*plain.StartTime)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "StartTime", `^[0-2]\d:[0-5]\d$`)
		}
	}
	*j = WapJsonMeta(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WapJson) UnmarshalJSON(value []byte) error {
	type Plain WapJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Days != nil && len(plain.Days) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "days", 1)
	}
	*j = WapJson(plain)
	return nil
}
